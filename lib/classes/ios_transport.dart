// Autogenerated from Pigeon (v9.2.5), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

/// Datasource interface to map to datasource class to iOS via pigeon.
class DataSourceIos {
  DataSourceIos({
    this.id,
    this.name,
    this.status,
    this.flags,
  });

  int? id;

  String? name;

  int? status;

  int? flags;

  Object encode() {
    return <Object?>[
      id,
      name,
      status,
      flags,
    ];
  }

  static DataSourceIos decode(Object result) {
    result as List<Object?>;
    return DataSourceIos(
      id: result[0] as int?,
      name: result[1] as String?,
      status: result[2] as int?,
      flags: result[3] as int?,
    );
  }
}

/// Version interface to map to version class to iOS via pigeon.
class Version {
  Version({
    this.major,
    this.middle,
    this.minor,
    this.build,
    this.year,
    this.month,
    this.day,
    this.hour,
    this.minute,
  });

  int? major;

  int? middle;

  int? minor;

  int? build;

  int? year;

  int? month;

  int? day;

  int? hour;

  int? minute;

  Object encode() {
    return <Object?>[
      major,
      middle,
      minor,
      build,
      year,
      month,
      day,
      hour,
      minute,
    ];
  }

  static Version decode(Object result) {
    result as List<Object?>;
    return Version(
      major: result[0] as int?,
      middle: result[1] as int?,
      minor: result[2] as int?,
      build: result[3] as int?,
      year: result[4] as int?,
      month: result[5] as int?,
      day: result[6] as int?,
      hour: result[7] as int?,
      minute: result[8] as int?,
    );
  }
}

/// Property interface to map to property class to iOS via pigeon.
class Property {
  Property({
    this.id,
    this.type,
    this.stringValue,
    this.longValue,
    this.arrayValue,
    this.byteValue,
    this.dataSourceValue,
    this.versionValue,
    this.objectValue,
  });

  int? id;

  int? type;

  String? stringValue;

  int? longValue;

  List<Object?>? arrayValue;

  int? byteValue;

  DataSourceIos? dataSourceValue;

  Version? versionValue;

  Object? objectValue;

  Object encode() {
    return <Object?>[
      id,
      type,
      stringValue,
      longValue,
      arrayValue,
      byteValue,
      dataSourceValue?.encode(),
      versionValue?.encode(),
      objectValue,
    ];
  }

  static Property decode(Object result) {
    result as List<Object?>;
    return Property(
      id: result[0] as int?,
      type: result[1] as int?,
      stringValue: result[2] as String?,
      longValue: result[3] as int?,
      arrayValue: result[4] as List<Object?>?,
      byteValue: result[5] as int?,
      dataSourceValue: result[6] != null
          ? DataSourceIos.decode(result[6]! as List<Object?>)
          : null,
      versionValue: result[7] != null
          ? Version.decode(result[7]! as List<Object?>)
          : null,
      objectValue: result[8] as Object?,
    );
  }
}

/// App info class specifically for iOS.
class IosAppInfo {
  IosAppInfo({
    this.appId,
    this.developerId,
    this.appKey,
  });

  String? appId;

  String? developerId;

  String? appKey;

  Object encode() {
    return <Object?>[
      appId,
      developerId,
      appKey,
    ];
  }

  static IosAppInfo decode(Object result) {
    result as List<Object?>;
    return IosAppInfo(
      appId: result[0] as String?,
      developerId: result[1] as String?,
      appKey: result[2] as String?,
    );
  }
}

/// Handle class specifically for iOS.
class IosTransportHandle {
  IosTransportHandle({
    this.value,
  });

  int? value;

  Object encode() {
    return <Object?>[
      value,
    ];
  }

  static IosTransportHandle decode(Object result) {
    result as List<Object?>;
    return IosTransportHandle(
      value: result[0] as int?,
    );
  }
}

/// Transport result class pecifically for iOS.
class IosTransportResult {
  IosTransportResult({
    this.value,
  });

  int? value;

  Object encode() {
    return <Object?>[
      value,
    ];
  }

  static IosTransportResult decode(Object result) {
    result as List<Object?>;
    return IosTransportResult(
      value: result[0] as int?,
    );
  }
}

class _IosTransportCodec extends StandardMessageCodec {
  const _IosTransportCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is DataSourceIos) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is IosAppInfo) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is IosTransportHandle) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is IosTransportResult) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is Property) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is Version) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return DataSourceIos.decode(readValue(buffer)!);
      case 129: 
        return IosAppInfo.decode(readValue(buffer)!);
      case 130: 
        return IosTransportHandle.decode(readValue(buffer)!);
      case 131: 
        return IosTransportResult.decode(readValue(buffer)!);
      case 132: 
        return Property.decode(readValue(buffer)!);
      case 133: 
        return Version.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// Extends HostApi class as metadata .
/// This file is meant to define a communication interface used to connect our existing classes to iOS.
class IosTransport {
  /// Constructor for [IosTransport].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  IosTransport({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _IosTransportCodec();

  Future<IosTransportHandle> openClient(IosAppInfo arg_appInfo) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.IosTransport.openClient', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_appInfo]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as IosTransportHandle?)!;
    }
  }

  Future<IosTransportHandle> openDevice(IosTransportHandle arg_handle, String arg_guid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.IosTransport.openDevice', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_handle, arg_guid]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as IosTransportHandle?)!;
    }
  }

  Future<IosTransportResult> close(IosTransportHandle arg_handle) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.IosTransport.close', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_handle]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as IosTransportResult?)!;
    }
  }

  Future<Property> getProperty(IosTransportHandle arg_handle, Property arg_property) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.IosTransport.getProperty', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_handle, arg_property]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as Property?)!;
    }
  }

  Future<Property> setProperty(IosTransportHandle arg_handle, Property arg_property) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.IosTransport.setProperty', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_handle, arg_property]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as Property?)!;
    }
  }
}
